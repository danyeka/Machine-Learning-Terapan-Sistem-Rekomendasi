# -*- coding: utf-8 -*-
"""notebook_rec.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xTDrJcKhCseMOYud1MwkR-PkY4LwfDQb

# **Recommendation System**

## Deskripsi Proyek


Kemajuan teknologi digital telah membuka akses luas ke konten film, namun juga menimbulkan tantangan bagi pengguna untuk memilih film yang sesuai. Sistem rekomendasi film hadir sebagai solusi untuk membantu pengguna menemukan film yang relevan dengan preferensi mereka.

Dataset diambil dari [https://grouplens.org/datasets/movielens/100k/]
"""

# Langkah 1: Unduh file zip dari URL
!wget -O ml-latest-small.zip https://files.grouplens.org/datasets/movielens/ml-latest-small.zip

# Langkah 2: Unzip file
!unzip ml-latest-small.zip

"""Mengunduh Dataset

## Import Library
"""

!pip install surprise scikit-surprise

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

"""## Data Understanding

### Gathering Data
"""

links = pd.read_csv('/content/ml-latest-small/links.csv')
movies = pd.read_csv('/content/ml-latest-small/movies.csv')
ratings = pd.read_csv('/content/ml-latest-small/ratings.csv')
tags = pd.read_csv('/content/ml-latest-small/tags.csv')
display(links.head(), links.shape, movies.head(), movies.shape, ratings.head(), ratings.shape, tags.head(), tags.shape)

"""Output dan Interpretasi
links.csv:

Berisi movieId, imdbId, dan tmdbId.

Jumlah baris: 9742, kolom: 3.

movies.csv:

Berisi movieId, title, dan genres.

Contoh: 'Toy Story (1995)' memiliki genre Adventure|Animation|Children|Comedy|Fantasy.

Jumlah baris: 9742, kolom: 3.

ratings.csv:

Informasi dari user yang memberi rating ke film.

Kolom: userId, movieId, rating, timestamp.

Jumlah baris: 100836, kolom: 4.

tags.csv:

Berisi tag atau label yang diberikan oleh user ke film.

Kolom: userId, movieId, tag, timestamp.

Jumlah baris: 3683, kolom: 4.

Kesimpulan Dokumentasi
Sel ini digunakan untuk memuat dan memverifikasi keempat dataset utama dari MovieLens. Setiap file CSV dibaca menggunakan pandas.read_csv() dan ditampilkan sebagian untuk memastikan data berhasil dimuat dengan benar. Selain itu, shape dari tiap dataset ditampilkan untuk mengetahui ukuran masing-masing dataset.

### Assessing Data

#### Checking Missing Value
"""

display(links.isnull().sum(), movies.isnull().sum(), ratings.isnull().sum(), tags.isnull().sum())

"""Untuk mengecek apakah terdapat missing values (nilai kosong) dalam masing-masing dataset: links, movies, ratings, dan tags.

Penjelasan fungsi:

.isnull() → Mengecek apakah sebuah nilai adalah NaN (missing/null).

.sum() → Menjumlahkan jumlah nilai NaN per kolom.

display() → Menampilkan hasil secara terstruktur di Jupyter Notebook.

links.csv:

tmdbId memiliki 8 missing values.

Kolom lainnya (movieId, imdbId) tidak memiliki missing values.

movies.csv, ratings.csv, dan tags.csv:

Tidak ada missing values di semua kolom.

Sel ini melakukan pengecekan missing value dari empat dataset menggunakan fungsi isnull().sum(). Hasilnya menunjukkan bahwa hanya kolom tmdbId dari dataset links yang memiliki 8 nilai kosong. Sementara itu, ketiga dataset lainnya (movies, ratings, dan tags) lengkap tanpa data yang hilang. Informasi ini penting untuk memutuskan apakah perlu melakukan data cleaning atau imputasi.

#### Checking Duplicate Data
"""

display(links.duplicated().sum(), movies.duplicated().sum(), ratings.duplicated().sum(), tags.duplicated().sum())

"""duplicated() → Mengecek apakah ada baris duplikat (baris yang isinya sama persis dengan baris lain).

sum() → Menjumlahkan jumlah baris duplikat pada masing-masing dataframe.

display() → Menampilkan hasilnya secara terstruktur.

Semua dataset tidak memiliki duplikat (nilai 0 untuk semua), sehingga tidak diperlukan pembersihan terkait duplikasi.

### Cleaning Data

### Exploratory Data Analysis (EDA)

#### Unique Value

##### Mengecek nilai unique untuk userid, movieid
"""

display(movies.movieId.nunique(), ratings.userId.nunique(), tags.userId.nunique(),
         tags.tag.nunique(), movies.genres.nunique())

"""Melihat jumlah data unik pada kolom movieId, userId, tag, dan genres untuk memahami sebaran data.

Film unik (movieId): 9742

User di ratings: 610

User di tags: 580

Tag unik: 1589

Kombinasi genre unik: 951

##### Mengecek nilai unique genre
"""

genres_split = movies.genres.str.split('|', expand=True)
genres_split.stack().unique()

"""str.split('|') → Memisahkan genre yang digabung dengan tanda |.

expand=True → Mengubah hasil split menjadi kolom-kolom baru.

stack() → Mengubah dataframe menjadi satu kolom panjang (stacked series).

.unique() → Menampilkan semua nilai unik dari genre tersebut.

Daftar genre unik ditemukan, antara lain:
Adventure, Animation, Children, Comedy, Fantasy, Romance, Drama, Crime, Thriller, Horror, Mystery, Sci-Fi, War, Musical, Documentary, IMAX, Western, Film-Noir, dan (no genres listed).

##### Mengecek value counts tiap genre
"""

genres_split = movies.genres.str.split('|').explode()
genre_counts = genres_split.value_counts()
genre_counts

"""Menghitung jumlah kemunculan masing-masing genre film dalam dataset. Ini penting untuk memahami distribusi film berdasarkan jenis genre.

str.split('|') → Memisahkan string genre yang digabung dengan karakter |.

.explode() → Mengubah list genre menjadi baris-baris terpisah (1 genre per baris).

.value_counts() → Menghitung frekuensi kemunculan setiap genre.

Insight
Drama dan Comedy adalah dua genre terbanyak di dataset.

Genre seperti Film-Noir, IMAX, dan genre kosong relatif jarang muncul.

Distribusi genre menunjukkan potensi ketidakseimbangan yang perlu diperhatikan dalam modeling seperti rekomendasi atau klasifikasi.

#### Wordcloud

##### Inisiasi fungsi wordcloud
"""

from wordcloud import WordCloud

def wordcloud(data, title):
    wc = WordCloud(width=800, height=400, max_words=200, background_color='white').generate(' '.join(data))
    plt.figure(figsize=(10, 8))
    plt.imshow(wc, interpolation='bilinear')
    plt.axis('off')
    plt.title(title)
    plt.show()

"""Visualisasi wordcloud digunakan untuk menampilkan kata-kata yang paling sering muncul pada kolom tag dari dataset. Ini membantu mengidentifikasi tema atau opini populer yang diasosiasikan dengan film oleh pengguna.

##### Wordcloud tags
"""

wordcloud(tags.tag, 'Tags WordCloud')

"""Insight dari Wordcloud
Tag yang paling sering muncul: “Netflix queue”, “thought provoking”, “suspense”, “atmospheric”, “sci-fi”, dan “action”.

Ada juga banyak kata dengan tema emosional, politik, psikologi, hingga cinematografi, menunjukkan variasi persepsi pengguna.

Tag-tag ini memberikan gambaran yang berguna untuk sistem rekomendasi berbasis konten (content-based filtering).

##### Wordcloud untuk Genre
"""

wordcloud(genres_split, 'Genres WordCloud')

"""genres_split adalah hasil dari pemisahan string genre berdasarkan delimiter '|' dan menggunakan .explode() agar setiap genre berada di baris terpisah.

Wordcloud ini mencerminkan jumlah kemunculan genre individual (contoh: "Drama", "Comedy", dsb.).


"""

wordcloud(movies.genres, 'Genres WordCloud')

"""Visualisasi ini langsung menggunakan kolom genres tanpa eksploitasi, sehingga satu string gabungan (misalnya "Comedy|Drama") dihitung sebagai satu tag unik.

Ini menyebabkan kombinasi genre muncul dalam wordcloud, misalnya "Comedy|Drama", bukan genre individu.

Insight dari Wordcloud
Genre paling dominan adalah: Drama, Comedy, Action, Sci-Fi, dan Romance.

Wordcloud dari genres_split memberikan representasi yang lebih akurat dari popularitas genre individu.

Sementara itu, wordcloud dari movies.genres menunjukkan kombinasi genre seperti "Comedy|Drama", "Action|Thriller", yang bisa digunakan untuk melihat pola penggabungan genre.

#### Film berdasarkan Rating

Menampilkan contoh isi dari tiga dataset penting dalam analisis sistem rekomendasi film, yaitu:

movies: Data utama berisi informasi film.

ratings: Data pengguna yang memberikan penilaian terhadap film.

tags: Data pengguna yang memberi tag atau label deskriptif ke film.
"""

display(movies.head(), ratings.head(), tags.head())

"""movies.head()
Kolom genres berisi gabungan beberapa genre yang dipisahkan dengan tanda |.

ratings.head()
Menunjukkan rating yang diberikan oleh pengguna ke film tertentu.
Nilai rating berada dalam skala (biasanya 0.5 hingga 5.0).
timestamp bisa dikonversi menjadi format waktu yang dapat dibaca manusia.

tags.head()
Data ini memperkaya film dengan tag yang menggambarkan konten, gaya, atau suasana film berdasarkan pendapat pengguna.


Data ratings memungkinkan kita menghitung rata-rata penilaian untuk menemukan film populer atau berkualitas tinggi.
Data tags memberikan informasi tambahan dari sisi persepsi pengguna yang bisa digunakan dalam sistem rekomendasi berbasis konten.

##### Menggabung data movies dan ratings
"""

movies_ratings = pd.merge(movies, ratings, on='movieId')
display(movies_ratings.head(), movies_ratings.shape)

"""Penjelasan:
Tujuan: Menggabungkan dua DataFrame, yaitu movies dan ratings, berdasarkan kolom movieId yang sama di keduanya.

pd.merge(..., on='movieId'): Melakukan merge antar dua tabel berdasarkan kolom movieId.

display(...): Menampilkan 5 baris pertama hasil penggabungan dan bentuk dimensinya (jumlah baris dan kolom).

Output memperlihatkan kolom: movieId, title, genres, userId, rating, dan timestamp.

#### Rata rata rating terendah film
"""

movies_ratings.groupby('title')['rating'].mean().sort_values(ascending=True).head(10)

"""Penjelasan:
Tujuan: Menghitung 10 film dengan rata-rata rating terendah.

groupby('title'): Mengelompokkan data berdasarkan judul film.

['rating'].mean(): Menghitung rata-rata rating untuk setiap film.

.sort_values(ascending=True): Mengurutkan dari yang terendah ke tertinggi.

.head(10): Mengambil 10 film dengan rating rata-rata terendah.

Output:
Menampilkan 10 judul film dengan rata-rata rating paling rendah, semuanya memiliki rating 0.5.

#### Rata rata rating tertinggi film
"""

movies_ratings.groupby('title')['rating'].mean().sort_values(ascending=False).head(10)

"""Penjelasan:
Tujuan: Menampilkan 10 film dengan rata-rata rating tertinggi.

groupby('title'): Mengelompokkan data berdasarkan judul film.

['rating'].mean(): Menghitung rata-rata rating untuk setiap film.

sort_values(ascending=False): Mengurutkan hasil dari yang tertinggi ke terendah.

head(10): Mengambil 10 film teratas berdasarkan rata-rata rating.

Output:
Menampilkan 10 judul film yang mendapatkan nilai rata-rata rating sempurna yaitu 5.0, menunjukkan film-film ini mendapat ulasan terbaik dari para pengguna.

#### Film yang paling banyak diberi rating
"""

movies_ratings.groupby('title')['rating'].count().sort_values(ascending=False).head(10).plot(kind='bar')

"""Penjelasan:
Tujuan: Menampilkan 10 film yang paling banyak menerima rating dari pengguna.

groupby('title'): Mengelompokkan data berdasarkan judul film.

['rating'].count(): Menghitung jumlah rating yang diberikan untuk setiap film.

sort_values(ascending=False): Mengurutkan dari jumlah rating terbanyak ke yang paling sedikit.

head(10): Mengambil 10 film teratas dengan jumlah rating terbanyak.

.plot(kind='bar'): Menampilkan hasilnya dalam bentuk grafik batang (bar chart).

Output:
Grafik batang menampilkan judul film di sumbu-x dan jumlah rating di sumbu-y.

Film seperti Forrest Gump (1994) dan The Shawshank Redemption (1994) menjadi yang paling banyak mendapat rating, menunjukkan popularitas dan keterlibatan pengguna terhadap film tersebut.

## Data Preparation

### General Data Preparation

Mengubah tipe data kolom timestamp menjadi datetime
"""

tags.timestamp = pd.to_datetime(tags.timestamp, unit='s')
ratings.timestamp = pd.to_datetime(ratings.timestamp, unit='s')
display(tags.head(), ratings.head())

"""Penjelasan:
pd.to_datetime(..., unit='s'): Mengonversi nilai timestamp dalam satuan detik ke format datetime.

Ini memudahkan analisis berbasis waktu seperti filtering berdasarkan tahun atau jam tertentu.

Fungsi display() digunakan untuk menampilkan data awal dari tags dan ratings setelah konversi.

Menggabung data movies dengan links
"""

movies_full = pd.merge(movies, links, on='movieId')
display(movies_full.head(), movies_full.shape, movies_full.isnull().sum())

"""Penjelasan:
pd.merge(movies, links, on='movieId'): Menggabungkan dua DataFrame berdasarkan kolom movieId.

Hasil penggabungan menciptakan satu DataFrame movies_full yang berisi informasi judul film, genre, dan ID dari IMDb serta TMDb.

movies_full.isnull().sum(): Mengecek apakah ada data yang hilang (missing values) di setiap kolom.


"""

links[links.tmdbId.isnull()]

"""Penjelasan:
links.tmdbId.isnull() menghasilkan boolean mask untuk baris yang nilai tmdbId-nya kosong.

Baris-baris ini ditampilkan agar bisa dianalisis sebelum dibuang.

Membuang baris yang terdapat nilai kosong (null)
"""

links.dropna(inplace=True)
display(links.head(),links.shape, links.isnull().sum())

""" Penjelasan:
links.dropna(inplace=True): Menghapus semua baris yang mengandung nilai NaN langsung dari DataFrame links tanpa membuat salinan baru.

links.shape: Menampilkan dimensi DataFrame setelah pembersihan.

links.isnull().sum(): Menampilkan jumlah nilai kosong di setiap kolom setelah proses pembersihan.

"""

movies['title'] = movies['title'].str.replace(r'\(\d{4}\)', '',
                                                        regex=True).str.strip()
movies['title'] = movies['title'].str.replace(r'\(\d{4}(–\d{4})?\)', '',
                                                        regex=True).str.strip()
display(movies, movies.isnull().sum())

"""Menghapus pola seperti (1995) dari judul film agar lebih bersih.

str.strip() digunakan untuk menghapus spasi kosong di awal dan akhir string.
"""

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

tfidf = TfidfVectorizer(stop_words='english')

movies['genres'] = movies['genres'].str.replace(r"[\[\]']", "", regex=True).str.replace("|", " ")

movies['features'] = movies['title'] + " " + movies['genres']
movies

"""Penjelasan:
Menghapus karakter [] dan ' dari string genre.

Mengganti | menjadi spasi agar genre terpisah lebih alami saat diolah model teks.

Kolom features berisi gabungan antara title dan genres, yang akan digunakan untuk analisis kemiripan (similarity).

### Data Preparation untuk Modelling Content Based Filtering

Mengubah fitur judul film menjadi matriks TF-IDF, lalu menghitung kesamaan antarfilm menggunakan cosine similarity untuk mendapatkan nilai kemiripan setiap film satu sama lain.
"""

tfidf_matrix = tfidf.fit_transform(movies['features'])
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)
cosine_sim

"""### Data Preparation untuk Modelling Collaborative Filtering

Membagi data menjadi train dan test, lalu menghitung RMSE dan MAE untuk evaluasi akurasi model.
"""

from surprise.model_selection import train_test_split
from surprise import Reader, Dataset
reader = Reader(rating_scale=(1, 5))
data = Dataset.load_from_df(ratings[['userId', 'movieId', 'rating']], reader)

trainset, testset = train_test_split(data, test_size=0.2, random_state=42)

"""# Model Development

## Content Based Filtering

Membuat fungsi untuk merekomendasikan 10 film mirip berdasarkan kesamaan judul yang diberikan, menggunakan cosine similarity.
"""

# Fungsi untuk rekomendasi film (Content Based Filtering menggunakan Cosine Similarity)
def recommend_movies(title, cosine_sim=cosine_sim):

    idx = movies[movies['title'] == title].index[0]

    sim_scores = list(enumerate(cosine_sim[idx]))

    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    sim_scores = sim_scores[1:11]

    movie_indices = [i[0] for i in sim_scores]

    return movies.iloc[movie_indices][['movieId','title', 'genres']]

"""Kode ini akan menampilkan 10 rekomendasi film yang mirip dengan "Jumanji" berdasarkan kesamaan konten film."""

recommend_movies("Jumanji")

"""Menampilkan 10 rekomendasi film yang mirip dengan "Toy Story" berdasarkan kesamaan konten film."""

recommend_movies("Toy Story")

"""Fungsi-fungsi untuk menghitung metrik evaluasi untuk sistem rekomendasi"""

def precision_recall_content_based(input_movie, recommended_movies, k=10):
    input_tfidf = tfidf.transform([input_movie])
    rec_tfidf = tfidf.transform(recommended_movies)

    sim_scores = cosine_similarity(input_tfidf, rec_tfidf)[0]
    precision = sum(sim_scores[:k]) / k
    recall = sum(sim_scores[:k]) / sum(sim_scores) if sum(sim_scores) > 0 else 0
    return precision * 100, recall * 100

input_movies = ["Toy Story", "Jumanji"]
recommendation_results = {movie: list(recommend_movies(movie)['title']) for movie in input_movies}

for movie in input_movies:
    recommended_titles = recommendation_results[movie]
    precision, recall = precision_recall_content_based(movie, recommended_titles, k=5)
    print(f"Precision@5 for '{movie}': {precision:.2f}%")
    print(f"Recall@5 for '{movie}': {recall:.2f}%")

"""## Collaborative Filtering"""

from surprise.model_selection import train_test_split
from surprise import SVD, Dataset, Reader
from surprise.model_selection import cross_validate
from surprise.accuracy import rmse, mae

"""Melatih model SVD untuk rekomendasi film"""

model = SVD()

model.fit(trainset)

predictions = model.test(testset)
print("Root Mean Squared Error (RMSE):", rmse(predictions))
print("Mean Absolute Error (MAE):", mae(predictions))

"""Fungsi ini merekomendasikan 10 film teratas yang belum pernah ditonton oleh pengguna berdasarkan prediksi rating model."""

def get_recommendations(user_id, movies_df, top_n=10):
    user_rated_movies = ratings[ratings['userId'] == user_id]['movieId'].values
    all_movie_ids = movies_df['movieId'].unique()
    unrated_movie_ids = np.setdiff1d(all_movie_ids, user_rated_movies)

    predictions = [model.predict(user_id, movie_id) for movie_id in unrated_movie_ids]
    predictions.sort(key=lambda x: x.est, reverse=True)

    recommended_movie_ids = [pred.iid for pred in predictions[:top_n]]
    recommendations = movies_df[movies_df['movieId'].isin(recommended_movie_ids)]
    return recommendations[['title', 'genres']]

"""Rekomendasi film untuk user id 331"""

get_recommendations(331, movies)

"""Rekomendasi film untuk user id 1"""

user_id = 1
recommended_movies = get_recommendations(user_id, movies)
print("Recommended Movies for User", user_id)
print(recommended_movies)